package  {	import flash.display.*;	import flash.events.*;	import fl.text.*;	import flash.text.*;	import flash.utils.*;	import flash.ui.Keyboard;	import flash.media.Sound;	import flash.media.SoundMixer;	import flashx.textLayout.formats.VerticalAlign;	import flash.ui.KeyLocation;	import flash.ui.Multitouch;	import com.google.analytics.AnalyticsTracker;	import KeyboardEventData;		public class Typewriter extends EventDispatcher {				protected var _stage:Stage;		protected var _text:TLFTextField;		protected var _text2:TLFTextField;		protected var _timer:Timer;		protected var _queue:Vector.<String>;		protected var _pendingCharacters:String;		protected var _pendingCharactersLen:int;		protected var _pendingCharacterIndex:int;		protected var _inputString:String;		protected var _lineWidth:Number;		protected var _backspaceEnabled:Boolean;		protected var _multilineMode:Boolean;		protected var _backspaceMessageShown:Boolean;		protected var _playhead:MovieClip;		protected var _keystrokes:MovieClip;		protected var _keyEvents:Vector.<KeyboardEventData>;		protected var _currentColumn:Number;		protected var _keystrokeTimer:Timer;		protected var _shifted:Boolean;		protected var _typing:Boolean;		protected var _shift:uint;		protected var _ignore:Boolean;		protected var _inputMode:Boolean;		protected var _backspaceTimer:Timer;		protected var _atTheReady:MovieClip;		protected var _showHands:Boolean;		protected var _speed:Number;		protected var _backspaces:Number;		protected var _tracker:AnalyticsTracker;		protected var _totalLines:int;				private var _arrListeners:Array = [];				public static var LEFT_KEYS:Array = ['tab','`','!','@','#','$','%','^','1','2','3','4','5','6','q','w','e','r','t','a','s','d','f','g','z','x','c','v','b'];		public static var LEFT_SHIFT_START:Number = 119;		public static var RIGHT_SHIFT_START:Number = 238;		public static var TAB_SIZE:int = 5;			public var computerTalksInUpperCase:Boolean = false;				public function Typewriter(text:TLFTextField, rate:Number=50.0, text2:TLFTextField=null, playhead:MovieClip=null, keystrokes:MovieClip=null, atTheReady:MovieClip = null, tracker:AnalyticsTracker = null, columns=30.0) {			_stage = text.stage;			_text = text;			_text.wordWrap = false;			_text.verticalAlign = flashx.textLayout.formats.VerticalAlign.BOTTOM;			_text.defaultTextFormat = new TextFormat("Courier New");			_tracker = tracker;			_totalLines = 0;						_text2 = text2;			if (text2) {				_text2.wordWrap = false;				_text2.verticalAlign = flashx.textLayout.formats.VerticalAlign.BOTTOM;				_text2.defaultTextFormat = new TextFormat("Courier New");			}									_playhead = playhead;			_keystrokes = keystrokes;			_atTheReady = atTheReady;			_showHands = false;			_speed = 1.0;						_atTheReady.addEventListener(MouseEvent.MOUSE_MOVE,onCursorOverTypewriter);			_atTheReady.addEventListener(MouseEvent.MOUSE_OUT,onCursorLeaveTypewriter);			_stage.addEventListener(Event.MOUSE_LEAVE,onCursorLeaveTypewriter);			_stage.addEventListener(Event.DEACTIVATE,onCursorLeaveTypewriter);			_lineWidth = columns;						// queue control			initQueue();						// keyboard control			_backspaces = 0;			_backspaceMessageShown = false;			_backspaceEnabled = true;			_ignore = false;			_multilineMode = false;			_currentColumn = 0;			_typing = false;			_inputMode = false;						// animation control			_keyEvents = new Vector.<KeyboardEventData>();			_timer = new Timer(rate);			_timer.addEventListener(TimerEvent.TIMER,onTick);			_keystrokeTimer = new Timer(rate);			_keystrokeTimer.addEventListener(TimerEvent.TIMER,onKeystrokeTick);			_stage.addEventListener(KeyboardEvent.KEY_DOWN,onKeyDown);			_stage.addEventListener(KeyboardEvent.KEY_UP,onKeyUp);			_timer.start();			_keystrokeTimer.start();			_shifted = false;			_shift = 0;		}						protected function onCursorOverTypewriter(e:MouseEvent):void {			_showHands = true;		}				protected function onCursorLeaveTypewriter(e:Event):void {			_showHands = false;		}				protected function initQueue():void {			_queue = new Vector.<String>();			_pendingCharacters = _inputString = "";			_pendingCharactersLen = _pendingCharacterIndex = 0;		}				public static function ltrim(s:String):String {			var i=-1;			while (s.charCodeAt(++i) < 33) {};			return s.substring(i);		}				public static function rtrim(s:String):String {			var i = s.length;			while (s.charCodeAt(--i) < 33) {};			return s.substring(0, ++i);		}				public static function trim(s:String):String {			if (s.search(/$\s+^/) == -1) {				return ltrim(rtrim(s));			} else {				return s;			}		}		//		public static function timeString():String {//			var d:Date = new Date();//			return d. + d.minutes.toString() + "." + Number((d.seconds * 10.0) / 60.0).toFixed(0));//		}				public function ready():void {			writeLine("R " + Number(Math.random()*3).toFixed(3) + "+" + Number(Math.random()*3).toFixed(3));		}				public function wait():void {			var d:Date = new Date();			writeLine("W " + d.hours.toString() + d.minutes.toString() + "." + Number((d.seconds * 10.0) / 60.0).toFixed(0));		}				public function cancel(returnCarriage:Boolean = true):void {			interrupt();			clearEventListeners();			//ignore(3000);		}				public function interrupt(returnCarriage:Boolean = true):void {			initQueue();			if (returnCarriage) {				writeLine();			}		}				public function yesNo(yes:Function, no:Function, message:String = null):void {			function f(s:String):void {				trace(s.toLowerCase());				s = s.toLowerCase();				if (s == "y" || s == "ye" || s == "yes" || s == "ok" || s == "sure") {					yes();				} else if (s == "n" || s == "no") {					no();				} else {					yesNo(yes,no,"PLEASE TYPE YES OR NO.");				}			}			readLine(f,message);		}				public function readLine(callback:Function, message:String = null, multiline:Boolean = false, trim:Boolean = true):void {			_inputString = "";						if (message) {				writeLine(message);			}						if (multiline) {				_multilineMode = true;			}						var f:Function = function (e:TypewriterEvent):void {				removeEventListener(TypewriterEvent.ENTER,f);				callback(trim ? Typewriter.trim(e.input) : e.input);			}			addEventListener(TypewriterEvent.ENTER,f);		}				public function writeLine(line:String = ""):void {			write(line + "\n");		}				protected function justify(s:String, justification:Boolean = false):String {			var n:String = "";			var lines:Array = s.split("\n");			for (var l:int = 0; l < lines.length; l++) {				if (lines[l].length > _lineWidth) {					while (true) {						if (lines[l].length > _lineWidth && lines[l].match(/.{31}/)[0].match(/\s/) == null) {							n+=lines[l].substr(0,31)+"\n";							lines[l] = lines[l].substr(31,lines[l].length);						} else {							// match the first 31 characters separately from any whitespace after those characters followed by word characters							var matches:Array = lines[l].match(/((.{31})(\s*\S*))/);							if (matches) {								// match the last non-whitespace characters of the first 31 characters (beginning of cut-off word)								var remainder:String = matches[0].match(/\s*\S*$/)[0];								// prepare the justified line-the line less the word characters at the end								var justified:String = lines[l].substr(0,matches[0].length-remainder.length);								// justify!								if (justification) {									var greatestSpaceCount = 1;									while (justified.length < lineWidth) {										var re:RegExp = new RegExp("\\b {"+greatestSpaceCount+"}\\b");										var loc:int = justified.search(re);										if (loc == -1) {											if (justified.lastIndexOf(" ") == -1) {												break;											} else {												greatestSpaceCount++;												continue;											}										} else {											justified = justified.substr(0,loc) + " " + justified.substr(loc,justified.length);										}									}								}								// clean up the remainder								remainder = Typewriter.ltrim(remainder);								n+=justified + "\n";								lines[l] = remainder + lines[l].substr(matches[0].length,lines[l].length);							} else {								n+=lines[l] + "\n";								break;							}						}					}				} else {					n+=lines[l] + "\n";				}			}			return n;		}				public function write(s:String):void {			if (s.length > _lineWidth) {				s = justify(s);			}			/*var wrapped:String = s.substring(0,Math.min(_lineWidth,s.length));			for (var i:int = _lineWidth; i < s.length; i+=_lineWidth) {				wrapped+="\n" + s.substring(i,Math.min(i+_lineWidth,s.length));			}			if (computerTalksInUpperCase) {				wrapped = wrapped.toUpperCase();			}*/			_queue.push(s);		}				public function playSound(char:String):void {			if (char == "\n" || char == "\r") {				//var ts:TypewriterLineBreak = new TypewriterLineBreak();				//ts.play();			} else {				//var tp:TypewriterPress = new TypewriterPress();				//tp.play();			}		}				protected function getFrameOfLabel(label:String):Number {						for (var i:int = 0; i < _keystrokes.currentLabels.length; i++) {				 var _fl:FrameLabel = _keystrokes.currentLabels[i];				if (_fl.name == label) {					return _fl.frame;				}			}			return -1;		}				protected function setKeystroke(e:KeyboardEventData):void {			var offset:Number = 0;			var labelToFrame:Number = 0			if (e.shiftKey) {				if ((e.keyCode == flash.ui.Keyboard.TAB) || (Typewriter.LEFT_KEYS.indexOf(String.fromCharCode(e.charCode).toLowerCase()) > -1)) {					offset = Typewriter.RIGHT_SHIFT_START;				} else {					offset = Typewriter.LEFT_SHIFT_START;				}			}						labelToFrame+=offset;						var char:String = String.fromCharCode(e.charCode).toLowerCase();						if (e.keyCode == flash.ui.Keyboard.ENTER) {				labelToFrame += getFrameOfLabel("return");			} else if (e.keyCode == flash.ui.Keyboard.SPACE) {				if (_shifted && _shift == 0) {					labelToFrame += getFrameOfLabel("rightSpace");				} else if (_shift == flash.ui.KeyLocation.LEFT) {					labelToFrame += getFrameOfLabel("rightSpace");				} else if (_shift == flash.ui.KeyLocation.RIGHT) {					labelToFrame += getFrameOfLabel("leftSpace");				} else {					labelToFrame +=getFrameOfLabel("leftSpace");				}			} else if (e.keyCode == flash.ui.Keyboard.PERIOD || char == ">") {				labelToFrame += getFrameOfLabel("period");			} else if (e.keyCode == flash.ui.Keyboard.COMMA || char == "<") {				labelToFrame += getFrameOfLabel("comma");			} else if (e.keyCode == flash.ui.Keyboard.EQUAL || char == "+") {				labelToFrame += getFrameOfLabel("equals");			} else if (e.keyCode == flash.ui.Keyboard.MINUS || char == "-" || char == "_") {				labelToFrame += getFrameOfLabel("dash");			} else if (e.keyCode == flash.ui.Keyboard.SEMICOLON || char == ":") {				labelToFrame += getFrameOfLabel("semicolon");			} else if (e.keyCode == flash.ui.Keyboard.BACKSPACE) {				labelToFrame += getFrameOfLabel("backspace");			} else if (e.keyCode == flash.ui.Keyboard.TAB) {				labelToFrame += getFrameOfLabel("tab");			} else if (e.keyCode == flash.ui.Keyboard.QUOTE || char == '"') {				labelToFrame += getFrameOfLabel("apostrophe");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_0 || char == ")") {				labelToFrame += getFrameOfLabel("zero");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_1 || char == "!") {				labelToFrame += getFrameOfLabel("one");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_2 || char == "@") {				labelToFrame += getFrameOfLabel("two");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_3 || char == "#") {				labelToFrame += getFrameOfLabel("three");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_4 || char == "$") {				labelToFrame += getFrameOfLabel("four");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_5 || char == "%") {				labelToFrame += getFrameOfLabel("five");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_6 || char == "^") {				labelToFrame += getFrameOfLabel("six");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_7 || char == "&") {				labelToFrame += getFrameOfLabel("seven");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_8 || char == "*") {				labelToFrame += getFrameOfLabel("eight");			} else if (e.keyCode == flash.ui.Keyboard.NUMBER_9 || char == "(") {				labelToFrame += getFrameOfLabel("nine");			} else if (e.keyCode == flash.ui.Keyboard.SLASH || char == "?") {				labelToFrame += getFrameOfLabel("slash");			} else if (e.keyCode == flash.ui.Keyboard.BACKSLASH || char == "}" || char == "|") {				labelToFrame += getFrameOfLabel("]");			} else if (e.keyCode == flash.ui.Keyboard.CAPS_LOCK) {				labelToFrame += getFrameOfLabel("capslock");			} else if (char == "{") {				labelToFrame += getFrameOfLabel("[");			} else {				labelToFrame += getFrameOfLabel(char);			}						_keystrokes.gotoAndStop(labelToFrame);		}				protected function pushKeystroke(e:KeyboardEvent):void {			if (e.keyCode != flash.ui.Keyboard.SHIFT) {				_keyEvents.push(new KeyboardEventData(e))				_keyEvents.push(null);			}		}				protected function onKeyUp(e:KeyboardEvent):void {			if (!e.shiftKey) {				_shift = 0;				_shifted = false;			}		}				protected function onKeyDown(e:KeyboardEvent):void {			// multiline disabled			if (!ignoring) {				if (e.keyCode == flash.ui.Keyboard.ENTER) {					// create and dispatch new enter event					var tE:TypewriterEvent = new TypewriterEvent();					tE.input = _inputString;					writeLine();					onTick(null);					// clear the input string					_inputString = "";					// update graphics					dispatchEvent(tE);				} else if (e.keyCode == flash.ui.Keyboard.BACKSPACE) {					if (_backspaceEnabled) {						_backspaceEnabled = false;						// reenable backspacing in 5 seconds						if (!_backspaceTimer) {							_backspaceTimer = new Timer(5000,1);							_backspaceTimer.addEventListener(TimerEvent.TIMER,function (e:TimerEvent):void {_backspaceEnabled = true;});						}						_backspaceTimer.reset();						_backspaceTimer.start();						// interrupt pending writes						interrupt();						// display a message						if (!_backspaceMessageShown) {							writeLine("YOU ATTEMPTED TO BACKSPACE. YOU CANNOT BACKSPACE ON A TYPEWRITER INTERFACE. PLEASE TRY YOUR INPUT AGAIN FROM THE BEGINNING.");							_backspaceMessageShown = true;						} else {							writeLine("TRY INPUT AGAIN.");						}						_backspaces++;						_tracker.trackEvent("mistakes","backspace","backspaces per user",_backspaces);						_inputString = "";					}				} else if (e.keyCode != flash.ui.Keyboard.SHIFT && 						   e.keyCode != flash.ui.Keyboard.CONTROL &&						   e.keyCode != flash.ui.Keyboard.COMMAND &&						   e.keyCode != flash.ui.Keyboard.ALTERNATE &&						   e.keyCode != flash.ui.Keyboard.CAPS_LOCK) {					var c:String = String.fromCharCode(e.charCode);					// if we're about to exceed the typewriter maximum, continue to the next line					if (e.keyCode == flash.ui.Keyboard.TAB) {						// five spaces aligned						var numSpaces:int = Typewriter.TAB_SIZE - _currentColumn % Typewriter.TAB_SIZE;						var spaces:String = "";						if (_currentColumn + numSpaces > lineWidth) {							writeLine();						}						for (; spaces.length < numSpaces; spaces = spaces.concat(" "));						_inputString += spaces;						write(spaces);						onTick(null);					} else {						if (_currentColumn + 1 > lineWidth) {							writeLine();						}						// print the character typed.						_inputString+=c;						write(c);						onTick(null);					}				}			}						if ((e.shiftKey) && (e.keyCode == flash.ui.Keyboard.SHIFT)) {				_shift = e.keyLocation;				_shifted = true;			}												pushKeystroke(e);		}				public function next(callback:Function) {			addEventListener(Event.COMPLETE,function callbackOnce():void {				removeEventListener(Event.COMPLETE,callbackOnce);				callback();			});		}				public function get lineWidth():Number {			return _lineWidth;		}				public function get ignoring():Boolean {			return _ignore;		}				public function set ignoring(value:Boolean):void {			_ignore = value;		}				public function ignore(duration:Number):void {			var t:Timer = new Timer(duration,(duration == 0 ? 0 : 1));			t.addEventListener(TimerEvent.TIMER,function (e:TimerEvent):void {ignoring = false});			ignoring = true;			t.start();		}				protected function onTick(e:TimerEvent):void {			if (_queue.length > 0) {				_typing = true;				if (_pendingCharacterIndex >= _pendingCharactersLen) {					_pendingCharacterIndex = 0;					_pendingCharacters = _queue.shift();					_pendingCharactersLen = _pendingCharacters.length;					appendChar();					setDelay();				} else {					appendChar();					setDelay();				}			} else if (_queue.length == 0) {				if (_pendingCharacterIndex < _pendingCharactersLen) {					_typing = true;					appendChar();					setDelay();				} else {					var len:int = _text.text.length;					//var beginning:int = Math.max(0,len-16*_lineWidth);					//_text.text = _text2.text = _text.text.substring(beginning,len);					if (len > (20 * _lineWidth)) {						_text.text = _text.text.substring(_lineWidth*4, len);						_text2.text = _text.text;						_text.verticalAlign = flashx.textLayout.formats.VerticalAlign.BOTTOM;						_text2.verticalAlign = flashx.textLayout.formats.VerticalAlign.BOTTOM;						_text.scrollV = _text.numLines;						_text2.scrollV = _text2.numLines;					}					_typing = false;					dispatchEvent(new Event(Event.COMPLETE));				}			}		}				protected function onKeystrokeTick(e:TimerEvent):void {			if (_keyEvents.length == 0) {				if (_shift == flash.ui.KeyLocation.LEFT) {					_keystrokes.gotoAndStop("leftShift");				} else if (_shift == flash.ui.KeyLocation.RIGHT) {					_keystrokes.gotoAndStop("rightShift");				} else if (_shifted) {					_keystrokes.gotoAndStop("leftShift");				} else if (_showHands) {					_keystrokes.gotoAndStop("hands");				} else {					_keystrokes.gotoAndStop("turnedOn");				}			} else {				var c = _keyEvents.shift();				if (c) {					setKeystroke(c);				} else {					_keystrokes.gotoAndStop(_keystrokes.currentFrame + 1);				}			}		}				public function get speed():Number {			return _speed;		}				public function set speed(v:Number):void {			_speed = v;		}				protected function setDelay():void {			var char:String = " ";			if (_pendingCharacterIndex < _pendingCharactersLen) {				char = _pendingCharacters.charAt(_pendingCharacterIndex);			}						if (_pendingCharactersLen > 1) {							if (char == " ") {					_timer.delay = (115.0+Math.random()*10)*_speed;				} else if (char == "\n") {					_timer.delay = (230.0+Math.random()*40)*_speed;				} else {					if (Math.random() < .0325) {						_timer.delay = (200+Math.random()*100)*_speed;					} else {						_timer.delay = (37.0+Math.random()*10)*_speed;					}				}			} else {				_timer.delay = 37.0*_speed;			}		}				protected function setPlayhead(char:String) {			if (char == "\n") {				//_totalLines+=1;				_currentColumn = 1;			} else {				_currentColumn++;			}			_playhead.gotoAndStop(Math.min(_currentColumn,_lineWidth));		}				protected function appendChar():void {			var char:String = _pendingCharacters.charAt(_pendingCharacterIndex);			_text.appendText(char);			if (_text2) {				_text2.appendText(char);			}			setPlayhead(char);			playSound(char);			_pendingCharacterIndex++;		}				override public function addEventListener(type:String, listener:Function, useCapture:Boolean=false, priority:int=0, useWeakReference:Boolean=false):void {			super.addEventListener(type, listener, useCapture, priority, useWeakReference);        	_arrListeners.push({type:type, listener:listener});		}				private function clearEventListeners():void {		   for(var i:Number = 0; i < _arrListeners.length; i++) {			  if (this.hasEventListener(_arrListeners[i].type)) {				 this.removeEventListener(_arrListeners[i].type, _arrListeners[i].listener);			  }		   }		   _arrListeners = [];		}	}}